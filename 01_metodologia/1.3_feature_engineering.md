# 1.3 Etapa 2: Feature Engineering

## Visão Geral

Esta é a etapa mais crítica do pipeline, onde criamos as features preditivas e os targets de sobrevivência. É aqui que transformamos dados brutos em informação útil para os modelos de Machine Learning.

## Objetivos

1. Criar targets de sobrevivência (pandemia e enchentes)
2. Derivar features temporais (idade, tempo de atividade)
3. Criar indicadores binários
4. Processar features categóricas
5. Preparar dataset final para modelagem

## Arquivo de Implementação

**Notebook:** `08_codigo/notebooks/3.1.ipynb`

**Localização dos dados:**
- **Entrada:** Dados agregados da Etapa 1
- **Saída:** `06_dados/processados/6_empresas_rs_porte_sobreviveu_pandemia_enchente.csv`

## Metodologia Detalhada

### 1. Definição de Períodos Críticos

```python
# Período da Pandemia
INICIO_PANDEMIA = pd.Timestamp('2020-03-01')
FIM_PANDEMIA = pd.Timestamp('2022-02-28')

# Período das Enchentes
INICIO_ENCHENTES = pd.Timestamp('2024-05-01')
FIM_ENCHENTES = pd.Timestamp('2024-12-31')
```

### 2. Criação de Targets

#### 2.1 Target: Sobrevivência na Pandemia

**Definição:** Uma empresa **sobreviveu à pandemia** se:
- Estava **aberta** em 01/03/2020 (início da pandemia)
- E continuou **aberta** em 28/02/2022 (fim do período crítico)

```python
def calcular_sobreviveu_pandemia(row):
    """
    Calcula se empresa sobreviveu à pandemia
    
    Args:
        row: Linha do DataFrame com datas
    
    Returns:
        int: 1 se sobreviveu, 0 caso contrário
    """
    data_inicio = pd.to_datetime(row['data_inicio_atividade'])
    data_situacao = pd.to_datetime(row['data_situacao_cadastral'])
    situacao = row['situacao_cadastral']
    
    # Empresa deve ter sido aberta antes ou no início da pandemia
    if data_inicio > INICIO_PANDEMIA:
        return 0  # Não existia no início da pandemia
    
    # Se ativa atualmente e não mudou situação durante pandemia
    if situacao == 'ATIVA':
        # Se nunca mudou de situação ou mudou antes da pandemia
        if data_situacao <= INICIO_PANDEMIA:
            return 1  # Sobreviveu
        # Se mudou para ativa durante ou após pandemia, verificar
        elif data_situacao <= FIM_PANDEMIA:
            return 0  # Mudou durante pandemia (possível fechamento temporário)
        else:
            return 1  # Mudou após pandemia, mas estava ativa durante
    
    # Se baixada, verificar quando
    elif situacao == 'BAIXADA':
        if data_situacao > FIM_PANDEMIA:
            return 1  # Fechou após pandemia (sobreviveu ao período)
        else:
            return 0  # Fechou durante ou antes da pandemia
    
    # Outras situações (suspensa, inapta, nula)
    else:
        return 0

# Aplicar
df['sobreviveu_pandemia'] = df.apply(calcular_sobreviveu_pandemia, axis=1)
```

#### 2.2 Target: Sobrevivência nas Enchentes

**Definição:** Uma empresa **sobreviveu às enchentes** se:
- Estava **aberta** em 01/05/2024 (início das enchentes)
- E continuou **aberta** após 31/12/2024 (fim do período de análise)

```python
def calcular_sobreviveu_enchente(row):
    """
    Calcula se empresa sobreviveu às enchentes
    
    Lógica similar a sobreviveu_pandemia, mas com datas diferentes
    """
    data_inicio = pd.to_datetime(row['data_inicio_atividade'])
    data_situacao = pd.to_datetime(row['data_situacao_cadastral'])
    situacao = row['situacao_cadastral']
    
    # Empresa deve existir no início das enchentes
    if data_inicio > INICIO_ENCHENTES:
        return 0
    
    # Lógica de verificação (similar à pandemia)
    if situacao == 'ATIVA':
        if data_situacao <= INICIO_ENCHENTES or data_situacao > FIM_ENCHENTES:
            return 1
        else:
            return 0
    elif situacao == 'BAIXADA':
        if data_situacao > FIM_ENCHENTES:
            return 1
        else:
            return 0
    else:
        return 0

# Aplicar
df['sobreviveu_enchente'] = df.apply(calcular_sobreviveu_enchente, axis=1)
```

### 3. Features Temporais

#### 3.1 Idade da Empresa

```python
# Data de referência (hoje)
DATA_REFERENCIA = pd.Timestamp.now()

# Idade em anos
df['idade_empresa_anos'] = (
    (DATA_REFERENCIA - pd.to_datetime(df['data_inicio_atividade'])).dt.days / 365.25
)

# Arredondar para 2 casas decimais
df['idade_empresa_anos'] = df['idade_empresa_anos'].round(2)

# Verificar valores
print(f"Idade mínima: {df['idade_empresa_anos'].min():.2f} anos")
print(f"Idade máxima: {df['idade_empresa_anos'].max():.2f} anos")
print(f"Idade média: {df['idade_empresa_anos'].mean():.2f} anos")
```

#### 3.2 Tempo na Situação Cadastral Atual

```python
# Tempo na situação atual em anos
df['tempo_situacao_anos'] = (
    (DATA_REFERENCIA - pd.to_datetime(df['data_situacao_cadastral'])).dt.days / 365.25
)

# Arredondar
df['tempo_situacao_anos'] = df['tempo_situacao_anos'].round(2)

# Valores negativos indicam problemas nos dados
df.loc[df['tempo_situacao_anos'] < 0, 'tempo_situacao_anos'] = 0
```

### 4. Indicadores Binários

```python
# Empresa ativa
df['empresa_ativa'] = (df['situacao_cadastral'] == 'ATIVA').astype(int)

# Empresa baixada
df['empresa_baixada'] = (df['situacao_cadastral'] == 'BAIXADA').astype(int)

# Empresa suspensa
df['empresa_suspensa'] = (df['situacao_cadastral'] == 'SUSPENSA').astype(int)

# Empresa inapta
df['empresa_inapta'] = (df['situacao_cadastral'] == 'INAPTA').astype(int)

# Verificar distribuição
print("Distribuição de Situação:")
print(df[['empresa_ativa', 'empresa_baixada', 'empresa_suspensa', 'empresa_inapta']].sum())
```

### 5. Processamento de Porte

```python
# Encoding ordinal de porte
porte_map = {
    'MEI': 0,           # Microempreendedor Individual
    'MICRO': 1,         # Microempresa
    'PEQUENA': 2,       # Pequena
    'MEDIA': 3,         # Média
    'GRANDE': 4         # Grande
}

df['porte_encoded'] = df['porte'].map(porte_map)

# Manter coluna original também
# df['porte'] permanece com valores textuais
```

### 6. Processamento de CNAE

```python
# Extrair seção CNAE (2 primeiros dígitos)
df['cnae_secao'] = df['cnae_fiscal_principal'].astype(str).str[:2]

# Agrupar CNAEs raros
cnae_counts = df['cnae_secao'].value_counts()
cnaes_raros = cnae_counts[cnae_counts < 100].index
df.loc[df['cnae_secao'].isin(cnaes_raros), 'cnae_secao'] = 'OUTROS'

# Encoding de frequência
cnae_freq = df['cnae_secao'].value_counts(normalize=True).to_dict()
df['cnae_frequencia'] = df['cnae_secao'].map(cnae_freq)
```

### 7. Features Geográficas

```python
# Município (manter código IBGE)
df['municipio_codigo'] = df['municipio'].astype(str)

# CEP - 3 primeiros dígitos (região)
df['cep_3_digitos'] = df['cep'].astype(str).str[:3]

# Tratar valores faltantes
df['cep_3_digitos'] = df['cep_3_digitos'].fillna('000')
```

## Estatísticas do Dataset Final

### Targets

```python
print("Distribuição de Targets:")
print(f"sobreviveu_pandemia:")
print(f"  1 (sobreviveu):     {(df['sobreviveu_pandemia']==1).sum():,} ({(df['sobreviveu_pandemia']==1).mean()*100:.2f}%)")
print(f"  0 (não sobreviveu): {(df['sobreviveu_pandemia']==0).sum():,} ({(df['sobreviveu_pandemia']==0).mean()*100:.2f}%)")
print()
print(f"sobreviveu_enchente:")
print(f"  1 (sobreviveu):     {(df['sobreviveu_enchente']==1).sum():,} ({(df['sobreviveu_enchente']==1).mean()*100:.2f}%)")
print(f"  0 (não sobreviveu): {(df['sobreviveu_enchente']==0).sum():,} ({(df['sobreviveu_enchente']==0).mean()*100:.2f}%)")
```

### Features Numéricas

```python
print("\nEstatísticas de Features Numéricas:")
print(df[['idade_empresa_anos', 'tempo_situacao_anos', 
          'porte_encoded', 'cnae_frequencia']].describe())
```

## Salvamento do Dataset

```python
# Colunas finais
colunas_finais = [
    'cnpj_basico',
    'porte',
    'porte_encoded',
    'situacao_cadastral',
    'motivo_situacao_cadastral',
    'cnae_fiscal_principal',
    'cnae_secao',
    'cnae_frequencia',
    'municipio_codigo',
    'cep_3_digitos',
    'data_inicio_atividade',
    'data_situacao_cadastral',
    'idade_empresa_anos',
    'tempo_situacao_anos',
    'empresa_ativa',
    'empresa_baixada',
    'empresa_suspensa',
    'empresa_inapta',
    'sobreviveu_pandemia',
    'sobreviveu_enchente'
]

# Selecionar e salvar
df_final = df[colunas_finais].copy()
output_path = '06_dados/processados/6_empresas_rs_porte_sobreviveu_pandemia_enchente.csv'
df_final.to_csv(output_path, index=False)

print(f"\n✅ Dataset final salvo:")
print(f"   Arquivo: {output_path}")
print(f"   Linhas: {len(df_final):,}")
print(f"   Colunas: {len(df_final.columns)}")
print(f"   Tamanho: {os.path.getsize(output_path) / 1024**2:.2f} MB")
```

## Decisões Importantes

### 1. Definição de Sobrevivência

**Por que usar abertura no início e fim do período?**
- Garante que empresa existia e operava
- Evita contar empresas que abriram durante a crise
- Foco em resiliência (sobreviver à crise), não crescimento (abrir durante)

### 2. Período de 2 Anos para Pandemia

**Por que março 2020 - fevereiro 2022?**
- Março 2020: Primeiras medidas de lockdown no Brasil
- Fevereiro 2022: Relaxamento significativo de restrições
- 2 anos: Tempo suficiente para impactos se manifestarem

### 3. Idade em Anos (não meses ou dias)

**Por que anos com decimais?**
- Interpretabilidade: Anos são mais intuitivos
- Precisão: Decimais capturam nuances (ex: 2.5 anos vs 2 anos)
- Escala: Modelos tree-based lidam bem com features contínuas

## Limitações

### 1. Definição Binária de Sobrevivência

**Limitação:** Não captura graus de dificuldade

**Exemplos não capturados:**
- Empresa que sobreviveu mas perdeu 80% de receita
- Empresa que fechou temporariamente e reabriu
- Empresa que mudou radicalmente (pivot)

**Mitigação Possível:**
- Target ordinal (falência, dificuldade, estável, crescimento)
- Múltiplos targets (fechou, mudou porte, mudou setor)
- Dados complementares (receita, funcionários)

### 2. Data de Situação Cadastral

**Limitação:** Pode haver defasagem entre realidade e registro

**Exemplo:**
- Empresa fecha em junho 2021
- Registro oficial só em agosto 2021
- 2 meses de diferença podem afetar classificação

**Mitigação:**
- Usar margem de tempo (considerar fechamentos até 3 meses após período)
- Cruzar com outras fontes (dados de posts, notas fiscais)

## Próximos Passos

Dataset está pronto para:

1. **Etapa 3: EDA** (`1.4_eda_analise_exploratoria.md`)
   - Análise exploratória
   - Identificação de padrões

2. **Etapa 4: Pipeline ML** (`1.5_pipeline_ml_base.md`)
   - Combinar com dados de posts
   - Modelagem

---

**Documento:** 1.3_feature_engineering.md  
**Versão:** 1.0  
**Data:** Dezembro 2024  
**Próximo:** [1.4 EDA](1.4_eda_analise_exploratoria.md)

